\chapter{MUD-\/\+Game }
\hypertarget{md_README}{}\label{md_README}\index{MUD-\/Game@{MUD-\/Game}}
\label{md_README_autotoc_md0}%
\Hypertarget{md_README_autotoc_md0}%
\hypertarget{md_README_autotoc_md1}{}\doxysection{\texorpdfstring{文件构成}{文件构成}}\label{md_README_autotoc_md1}

\begin{DoxyCode}{0}
\DoxyCodeLine{.}
\DoxyCodeLine{├──\ CMakelists.txt\ \ \ \ \#\ 制定编译文件}
\DoxyCodeLine{├──\ README.md\ \ \ \ \ \ \ \ \ \#\ 项目说明}
\DoxyCodeLine{├──\ src\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \#\ 项目代码}
\DoxyCodeLine{└──\ tests\ \ \ \ \ \ \ \ \ \ \ \ \ \#\ 测试代码}

\end{DoxyCode}
\hypertarget{md_README_autotoc_md2}{}\doxysection{\texorpdfstring{规范}{规范}}\label{md_README_autotoc_md2}
\hypertarget{md_README_autotoc_md3}{}\doxysubsection{\texorpdfstring{注释}{注释}}\label{md_README_autotoc_md3}
注释使用 \href{https://doxygen.nl/manual/}{\texttt{Doxygen}} 规范，这个框架可以方便地生成项目文档供其他成员使用，而且注释的可读性很高，上手简单，用 AI 生成几个例子就会了。

\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Doxygen 可用标签速查\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}：\href{https://www.doxygen.nl/manual/commands.html}{\texttt{Special Commands}}\hypertarget{md_README_autotoc_md4}{}\doxysubsection{\texorpdfstring{测试框架}{测试框架}}\label{md_README_autotoc_md4}
测试框架我以前用过一个更小型的，用起来很香，可以非常快速的测试代码。他可以让我们预先设定好什么场景下程序应该有怎样的行为，如果我们设置了若干个场景，那么每次修改完代码就可以通过测试框架测试现在的代码对所有场景是否都适用。我们这个项目就使用 Catch (比较轻量化)\hypertarget{md_README_autotoc_md5}{}\doxysubsection{\texorpdfstring{Git}{Git}}\label{md_README_autotoc_md5}

\begin{DoxyEnumerate}
\item 应当尽量避免 merge 而是使用 rebase, 一个常见的工作流可以参见这个\href{bilibili.com/video/BV19e4y1q7JJ/?spm_id_from=333.337.search-card.all.click}{\texttt{视频}}，不同的是我们使用 pull request 来合并到 master 分支
\item 尽量规范的书写 commit 的描述，这可以帮助我们准确的寻找并回滚代码，参见\href{https://zhuanlan.zhihu.com/p/182553920}{\texttt{如何规范你的\+Git commit}}
\item 大家添加新功能的时候请添加一个新分支，比如我要写一个地图的新功能，我就会从 master 新建一个 feature-\/map 分支出来，写完所有功能，并且测试完成之后，再写一个 PR 合并到 master 分支（直接在 master 分支编辑真的会出现意想不到的错误😭）
\end{DoxyEnumerate}\hypertarget{md_README_autotoc_md6}{}\doxysubsection{\texorpdfstring{编码规范}{编码规范}}\label{md_README_autotoc_md6}
大家可以先去读一下 Google 的 Style document, 讲了各种场景下的编码规范，按照规范写的代码可读性一般都很高。\hypertarget{md_README_autotoc_md7}{}\doxysubsubsection{\texorpdfstring{命名}{命名}}\label{md_README_autotoc_md7}
然后我就确定一下命名规范了，大家觉得这种格式不合适可以提一下建议：


\begin{DoxyItemize}
\item 变量：变量采用蛇形命名法，即 {\ttfamily min\+\_\+value} 的形式
\item 函数：函数采用小驼峰命名法，即 {\ttfamily get\+Value} 的形式
\item 类：采用大驼峰命名法，即 {\ttfamily Map\+Loader} 的形式
\item 常量：采用全大写加下划线分割，即 {\ttfamily MATH\+\_\+\+PI} 的形式
\end{DoxyItemize}

大家可以自行补充\hypertarget{md_README_autotoc_md8}{}\doxysubsubsection{\texorpdfstring{using}{using}}\label{md_README_autotoc_md8}
这个地方强烈建议\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}不要\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}使用 {\ttfamily using namespace std;} 的形式直接导入命名空间，这会导致命名冲突问题，更好的方案是导入常用的函数、变量等：


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ 划分成多行只是为了格式美观}}
\DoxyCodeLine{\textcolor{keyword}{using\ }std::cin,\ std::cout;}
\DoxyCodeLine{\textcolor{keyword}{using\ }std::string,\ std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ 如果想使用\ vector}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <vector>}}
\DoxyCodeLine{\textcolor{comment}{//\ 如果需要频繁用到}}
\DoxyCodeLine{\textcolor{keyword}{using\ }std::vector;}
\DoxyCodeLine{vector<int>\ my\_vector;}
\DoxyCodeLine{\textcolor{comment}{//\ 不需要频繁使用}}
\DoxyCodeLine{\textcolor{comment}{//\ std::vector<int>\ my\_vecotr;}}

\end{DoxyCode}
 